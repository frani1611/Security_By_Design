name: CI Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch: {}

permissions:
  contents: read
  actions: write
  packages: write
  security-events: write
  id-token: write

env:
  IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/social-media-dashboard
  IMAGE_TAG: ${{ github.sha }}

jobs:
  debug-token:
    name: Debug GITHUB_TOKEN access
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'push'
    steps:
      - name: Show run and token info
        run: |
          echo "Run id: ${{ github.run_id }}"
          echo "Event: ${{ github.event_name }}"
          echo "Repository: ${{ github.repository }}"
      - name: Test Actions REST API with GITHUB_TOKEN
        env:
          GHTOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          API_URL="https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo "Calling: $API_URL"
          http_status=$(curl -s -o response.json -w "%{http_code}" -H "Authorization: Bearer $GHTOKEN" -H "Accept: application/vnd.github+json" "$API_URL") || true
          echo "HTTP status: $http_status"
          echo "Response body:" 
          cat response.json || true

  sbom:
    name: Generate SBOM
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install Syft
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
      - name: Generate SBOM (CycloneDX JSON)
        run: |
          syft packages dir:. -o cyclonedx-json > sbom.cyclonedx.json
      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.cyclonedx.json

  codeql:
    name: CodeQL SAST
    runs-on: ubuntu-latest
    needs: sbom
    steps:
      - uses: actions/checkout@v4
      # CodeQL Action v4: update before v3 deprecation (Dec 2026)
      # Note: Ensure 'Code scanning' is enabled in repository settings
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v4
        with:
          languages: javascript
      - name: Autobuild
        uses: github/codeql-action/autobuild@v4
      - name: Run CodeQL
        uses: github/codeql-action/analyze@v4

  secret-scan:
    name: Secret Scan (gitleaks)
    runs-on: ubuntu-latest
    needs: codeql
    steps:
      - uses: actions/checkout@v4
      - name: Run gitleaks (install + detect)
        run: |
          # Install dependencies and gitleaks (use sudo to ensure /usr/local/bin is writable)
          sudo apt-get update -y
          sudo apt-get install -y jq ca-certificates
          # Remove any existing gitleaks to avoid shadowing older binaries
          sudo rm -f /usr/local/bin/gitleaks /usr/bin/gitleaks || true
          # Prefer the upstream install script; fallback to direct asset download if it fails
          set -e
          echo "Attempting to install gitleaks via install.sh"
          if curl -sSfL https://raw.githubusercontent.com/zricethezav/gitleaks/master/install.sh | sudo bash -s -- -b /usr/local/bin; then
            echo "gitleaks installed via install.sh"
          else
            echo "install.sh failed, attempting direct asset download"
            ARCH=$(uname -m)
            case "$ARCH" in
              x86_64|amd64) ASSET="gitleaks-linux-amd64" ;;
              aarch64|arm64) ASSET="gitleaks-linux-arm64" ;;
              *) ASSET="gitleaks-linux-amd64" ;;
            esac
            GITLEAKS_URL="https://github.com/zricethezav/gitleaks/releases/latest/download/${ASSET}"
            echo "Downloading $GITLEAKS_URL"
            curl -sSL --retry 3 --retry-delay 2 -f "$GITLEAKS_URL" -o /tmp/gitleaks
            sudo mv /tmp/gitleaks /usr/local/bin/gitleaks
            sudo chmod +x /usr/local/bin/gitleaks
          fi
          # Ensure /usr/local/bin is in PATH
          export PATH=/usr/local/bin:$PATH
          # Print version for debugging (non-fatal)
          gitleaks version || true
          # Run detect but don't let a non-zero exit (findings) stop the job â€” report will be checked later
          set -x
          gitleaks detect --source . --report-format json --report-path gitleaks-report.json || true
      - name: Upload gitleaks report
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-report
          path: gitleaks-report.json
      - name: Fail if secrets found
        run: |
          if [ -s gitleaks-report.json ] && grep -q '[\[{]' gitleaks-report.json; then
            echo "Secrets detected by gitleaks, failing pipeline."
            jq length gitleaks-report.json | grep -q '^0$' || (cat gitleaks-report.json && exit 1)
          fi

  sca-scan:
    name: SCA Scan (Trivy)
    runs-on: ubuntu-latest
    needs: secret-scan
    steps:
      - uses: actions/checkout@v4
      - name: Install trivy
        run: |
          curl -sSfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin
      - name: Run Trivy filesystem scan
        run: |
          trivy fs --format json --output trivy-fs.json .
      - name: Upload Trivy report
        uses: actions/upload-artifact@v4
        with:
          name: trivy-report
          path: trivy-fs.json

  build-and-push:
    name: Build and push image
    runs-on: ubuntu-latest
    needs: sca-scan
    environment: production
    outputs:
      image_digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4
      - name: Check GHCR_TOKEN availability
        run: |
          if [ -z "${{ secrets.GHCR_TOKEN }}" ]; then
            echo "GHCR_TOKEN is not set in repository secrets. Create a Personal Access Token (fine-grained recommended) with Packages: Read & write and add it as GHCR_TOKEN."
            exit 1
          fi
          echo "GHCR_TOKEN length: $(echo -n "${{ secrets.GHCR_TOKEN }}" | wc -c) characters"
      - name: Log in to GHCR
        # Note: Use a fine-grained Personal Access Token (PAT) named `GHCR_TOKEN` with:
        # - Repository access: Only select repositories -> choose this repo
        # - Packages: Read & write
        # If the repo is private also grant `Contents: Read`/`repo` as needed for classic tokens.
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GHCR_TOKEN }}
      - name: Build and push image
        id: build
        uses: docker/build-push-action@v4
        with:
          context: ./Code/social-media-dashboard/backend
          file: ./Code/social-media-dashboard/backend/Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
            ${{ env.IMAGE_NAME }}:latest
          # build-push-action provides step output 'digest' when pushing

  sign-image:
    name: Sign image with cosign
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - name: Prepare debug info (non-sensitive)
        if: github.ref == 'refs/heads/main'
        run: |
          echo "GITHUB_REPOSITORY=$GITHUB_REPOSITORY"
          echo "GITHUB_ACTOR=$GITHUB_ACTOR"
          echo "IMAGE=${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
      - name: Install cosign via action
        if: github.ref == 'refs/heads/main'
        uses: sigstore/cosign-installer@v3
      - name: Log in to GHCR for signing (use GHCR_TOKEN or fallback to GITHUB_TOKEN)
        if: github.ref == 'refs/heads/main'
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN || github.token }}
      - name: Sign image (keyless) using cosign CLI
        if: github.ref == 'refs/heads/main'
        env:
          COSIGN_EXPERIMENTAL: "true"
          COSIGN_YES: "true"
        run: |
          cosign version || true
          # keyless is the default when no --key is provided; do not pass --keyless flag
          # Prefer signing by digest to avoid tag-mutation issues. If build produced a digest, use it.
          if [ -n "${{ needs.build-and-push.outputs.image_digest }}" ]; then
            IMAGE_REF="${{ env.IMAGE_NAME }}@${{ needs.build-and-push.outputs.image_digest }}"
          else
            IMAGE_REF="${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
          fi
          echo "Signing image: $IMAGE_REF"
          cosign sign "$IMAGE_REF"

  quality-gate:
    name: Quality Gate
    runs-on: ubuntu-latest
    needs: [sign-image, sca-scan, secret-scan, build-and-push]
    steps:
      - uses: actions/checkout@v4
      - name: Setup Python (ensure python3 available)
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: trivy-report
          path: reports
      - name: Check Trivy for CVSS >= 7.0 or HIGH/CRITICAL
        run: |
          python3 .github/scripts/quality_gate.py reports/trivy-fs.json
      - name: Verify cosign signature (keyless)
        run: |
          cosign verify --keyless ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} || (echo "Signature missing/invalid" && exit 1)

  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: quality-gate
    steps:
      - uses: actions/checkout@v4
      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.27.3'
      - name: Setup kubeconfig
        env:
          KUBECONFIG_DATA: ${{ secrets.KUBECONFIG }}
        run: |
          echo "$KUBECONFIG_DATA" > kubeconfig
          export KUBECONFIG=$PWD/kubeconfig
      - name: Update k8s manifests with new image and apply
        run: |
          sed -i "s#IMAGE_PLACEHOLDER#${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}#g" k8s/backend-deployment.yaml || true
          kubectl apply -f k8s/
